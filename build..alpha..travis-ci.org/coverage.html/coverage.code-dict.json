{"/home/travis/build/npmtest/node-npmtest-massive/test.js":"/* istanbul instrument in package npmtest_massive */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-massive/lib.npmtest_massive.js":"/* istanbul instrument in package npmtest_massive */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_massive = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_massive = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-massive/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-massive && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_massive */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_massive\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_massive.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_massive.rollup.js'] =\n            local.assetsDict['/assets.npmtest_massive.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_massive.__dirname + '/lib.npmtest_massive.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/index.js":"var Runner = require(\"./lib/runner\");\nvar _ = require(\"underscore\")._;\nvar fs = require(\"fs\");\nvar Executable = require(\"./lib/executable\");\nvar Queryable = require(\"./lib/queryable\");\nvar Table = require(\"./lib/table\");\nvar util = require(\"util\");\nvar ArgTypes = require(\"./lib/arg_types\");\nvar path = require(\"path\");\nvar DA = require('deasync');\nvar stripBom = require('strip-bom');\n\nvar self;\n\nif (typeof Promise == 'undefined') {\n  global.Promise = require('promise-polyfill');\n}\n\nvar Massive = function(args) {\n  this.scriptsDir = args.scripts || process.cwd() + \"/db\";\n  this.enhancedFunctions = args.enhancedFunctions || false;\n\n  var runner = new Runner(args.connectionString, args.defaults);\n  _.extend(this, runner);\n\n  this.tables = [];\n  this.views = [];\n  this.queryFiles = [];\n  this.schemas = [];\n  this.functions = [];\n\n  if (args.whitelist) {\n    this.whitelist = this.getTableFilter(args.whitelist);\n  } else {\n    this.allowedSchemas = this.getSchemaFilter(args.schema);\n    this.blacklist = this.getTableFilter(args.blacklist);\n    this.exceptions = this.getTableFilter(args.exceptions);\n  }\n  // any \"truthy\" value passed will cause functions to be excluded. No param\n  // will be a \"falsy\" value, and functions will be included...\n  this.excludeFunctions = args.excludeFunctions;\n  this.functionBlacklist = this.getTableFilter(args.functionBlacklist);\n  this.functionWhitelist = this.getTableFilter(args.functionWhitelist);\n};\n\nMassive.prototype.getSchemaFilter = function(allowedSchemas) {\n  // an empty string will cause all schema to be loaded by default:\n  var result = '';\n  if(allowedSchemas === 'all' || allowedSchemas === '*') {\n    // Do nothing else. Leave the default empty string:\n    allowedSchemas = null;\n  }\n  if(allowedSchemas) {\n    // there is a value of some sort other than our acceptable defaults:\n    if(_.isString(allowedSchemas)) {\n      // a string works. If comma-delimited, so much the better, we're done:\n      result = allowedSchemas;\n    } else {\n      if(!_.isArray(allowedSchemas)) {\n        throw(\"Specify allowed schemas using either a commma-delimited string or an array of strings\");\n      }\n      // create a comma-delimited string:\n      result = allowedSchemas.join(\", \");\n    }\n  }\n  return result;\n};\n\nMassive.prototype.getTableFilter = function(filter) {\n  // an empty string will cause all schema to be loaded by default:\n  var result = '';\n  if(filter) {\n    // there is a value of some sort other than our acceptable defaults:\n    if(_.isString(filter)) {\n      // a string works. If comma-delimited, so much the better, we're done:\n      result = filter;\n    } else {\n      if(!_.isArray(filter)) {\n        throw(\"Specify filter patterns using either a commma-delimited string or an array of strings\");\n      }\n      // create a comma-delimited string:\n      result = filter.join(\", \");\n    }\n  }\n  return result;\n};\n\nMassive.prototype.run = function(){\n  var args = ArgTypes.queryArgs(arguments);\n  this.query(args);\n};\nMassive.prototype.runSync = DA(Massive.prototype.run);\n\nMassive.prototype.loadQueries = function() {\n  walkSqlFiles(this, this.scriptsDir);\n};\n\nMassive.prototype.loadTables = function(next) {\n  var tableSql = __dirname + \"/lib/scripts/tables.sql\";\n  var parameters = [this.allowedSchemas, this.blacklist, this.exceptions];\n  var self = this;\n\n  // ONLY allow whitelisted items:\n  if(this.whitelist) {\n    tableSql = __dirname + \"/lib/scripts/whitelist.sql\";\n    parameters = [this.whitelist];\n  }\n\n  this.executeSqlFile({file : tableSql, params: parameters}, function(err, tables) {\n    if (err) { return next(err, null); }\n\n    _.each(tables, function(table){\n      var _table = new Table({\n        schema : table.schema,\n        name : table.name,\n        pk : table.pk,\n        db : self\n      });\n\n      MapToNamespace(_table);\n    });\n\n    next(null,self);\n  });\n};\n\nMassive.prototype.loadDescendantTables = function(next) {\n  var tableSql = __dirname + \"/lib/scripts/descendant_tables.sql\";\n  var parameters = [this.allowedSchemas, this.blacklist, this.exceptions];\n  var self = this;\n\n  this.executeSqlFile({file : tableSql, params: parameters}, function(err, descendantTables) {\n    if (err) { return next(err, null); }\n\n    _.each(descendantTables, function (table) {\n      // if parent table is already defined it means it has been whitelisted / validated\n      // so we safely can add the descendant to the available tables\n      if (undefined !== typeof self[table.parent]) {\n        var _table = new Table({\n          schema : table.schema,\n          name : table.child,\n          pk : self[table.parent].pk,\n          db : self\n        });\n\n        MapToNamespace(_table);\n      }\n    });\n\n    next(null, self);\n  });\n};\n\nMassive.prototype.loadViews = function(next) {\n  var viewSql = __dirname + \"/lib/scripts/views.sql\";\n  var parameters = [this.allowedSchemas, this.blacklist, this.exceptions];\n\n  this.executeSqlFile({file : viewSql, params: parameters}, function(err, views){\n    if (err) { return next(err, null); }\n\n    _.each(views, function(view) {\n      var _view = new Queryable({\n        schema : view.schema,\n        name : view.name,\n        db : self\n      });\n\n      MapToNamespace(_view, \"views\");\n    });\n\n    next(null, self);\n  });\n};\n\nMassive.prototype.saveDoc = function(collection, doc, next){\n  // default is public. Table constructor knows what to do if 'public' is used as the schema name:\n  var schemaName = \"public\";\n  var tableName = collection;\n  var potentialTable = null;\n\n    // is the collection namespace delimited?\n  var splits = collection.split(\".\");\n  if(splits.length > 1) {\n    // uh oh. Someone specified a schema name:\n    schemaName = splits[0];\n    tableName = splits[1];\n    potentialTable = self[schemaName][tableName];\n  } else {\n    potentialTable = self[tableName];\n  }\n\n  if(potentialTable) {\n    potentialTable.saveDoc(doc, next);\n  } else {\n    var _table = new Table({\n    schema : schemaName,\n     pk : \"id\",\n     name : tableName,\n     db : self\n    });\n\n    // Create the table in the back end:\n    var sql = this.documentTableSql(collection);\n\n    this.query(sql, function(err){\n      if(err){\n        next(err,null);\n      } else {\n        MapToNamespace(_table);\n        // recurse\n        self.saveDoc(collection,doc,next);\n      }\n    });\n  }\n};\nMassive.prototype.saveDocSync = DA(Massive.prototype.saveDoc);\n\nvar MapToNamespace = function(entity, collection) {\n  collection = collection || \"tables\";\n\n  var db = entity.db;\n  var executor;\n  var schemaName;\n\n  // executables are always invoked directly, so we need to handle them a bit differently\n  if (entity instanceof Executable) {\n    executor = function () {\n      entity.invoke.apply(entity, arguments);\n    };\n  }\n\n  if (entity.schema === \"public\") {\n    db[entity.name] = executor || entity;\n  } else {\n    schemaName = entity.schema;\n    // is this schema already attached?\n    if(!db[schemaName]) {\n      // if not, then bolt it on:\n      db[schemaName] = {};\n    }\n    // attach the entity to the schema:\n    db[schemaName][entity.name] = executor || entity;\n  }\n\n  db[collection].push(entity);\n};\n\nvar RemoveFromNamespace = function(db, table) {\n  // right now only tables are supported\n  var collection = \"tables\";\n\n  var splits = table.split('.');\n  var tableName, schemaName;\n\n  if(splits.length > 1) {\n    schemaName = splits[0];\n    tableName = splits[1];\n  } else {\n    schemaName = \"public\";\n    tableName = table;\n  }\n\n  if(schemaName === \"public\" && db[table]) {\n    delete db[table];\n  }else if(db[schemaName] && db[schemaName][tableName]) {\n    delete db[schemaName][tableName];\n  }\n\n  if(db[collection]) {\n    db[collection] = _.reject(db[collection], function(element) {\n      return element.name && element.schema && element.schema === schemaName && element.name === tableName;\n    });\n  }\n};\n\n\nMassive.prototype.createDocumentTable = function(path, next) {\n  // Create the table in the back end:\n  var splits = path.split(\".\");\n  var tableName;\n  var schemaName;\n  if(splits.length > 1) {\n    // uh oh. Someone specified a schema name:\n    schemaName = splits[0];\n    tableName = splits[1];\n  } else {\n    schemaName = \"public\"; // default schema\n    tableName = path;\n  }\n\n  var _table = new Table({\n  schema : schemaName,\n   pk : \"id\",\n   name : tableName,\n   db : self\n  });\n\n  var sql = this.documentTableSql(path);\n\n  this.query(sql, function(err, res){\n    if(err){\n      next(err,null);\n    } else {\n      MapToNamespace(_table);\n      next(null, res);\n    }\n  });\n};\n\nMassive.prototype.documentTableSql = function(tableName){\n  var docSqlFile = __dirname + \"/lib/scripts/create_document_table.sql\";\n  var sql = fs.readFileSync(docSqlFile, {encoding: 'utf-8'});\n\n  var indexName = tableName.replace(\".\", \"_\");\n  sql = util.format(sql, tableName, indexName, tableName, indexName, tableName);\n  return sql;\n};\n\n\nMassive.prototype.dropTable = function(table, options, next) {\n  var sql = this.dropTableSql(table, options);\n  this.query(sql, function(err, res) {\n    if(err) {\n      next(err, null);\n    } else {\n      RemoveFromNamespace(self, table);\n      next(null, res);\n    }\n  });\n};\n\nMassive.prototype.dropTableSql = function(tableName, options){\n  var docSqlFile = __dirname + \"/lib/scripts/drop_table.sql\";\n  var sql = fs.readFileSync(docSqlFile, {encoding: 'utf-8'});\n  var cascadeOpt = options && options.cascade === true ? \"CASCADE\" : \"\";\n  sql = util.format(sql, tableName, cascadeOpt);\n  return sql;\n};\n\nMassive.prototype.createSchema = function(schemaName, next) {\n  var sql = this.createSchemaSql(schemaName);\n  this.query(sql, function(err, res) {\n    if(err) {\n      next(err);\n    } else {\n      self[schemaName] = {};\n      next(null, res);\n    }\n  });\n};\n\nMassive.prototype.createSchemaSql = function(schemaName) {\n  var docSqlFile = __dirname + \"/lib/scripts/create_schema.sql\";\n  var sql = fs.readFileSync(docSqlFile, {encoding: 'utf-8'});\n\n  sql = util.format(sql, schemaName);\n  return sql;\n};\n\nMassive.prototype.dropSchema = function(schemaName, options, next) {\n  var sql = this.dropSchemaSql(schemaName, options);\n\n  this.query(sql, function(err, res) {\n    if(err) {\n      next(err);\n    } else {\n      // Remove all the tables from the namespace\n      if(self[schemaName]) {\n        _.each(Object.keys(self[schemaName]), function(table) {\n          RemoveFromNamespace(self, schemaName + \".\" + table);\n        });\n      }\n      // Remove the schema from the namespace\n      delete self[schemaName];\n      next(null, res);\n    }\n  });\n};\n\nMassive.prototype.dropSchemaSql = function(schemaName, options) {\n  var docSqlFile = __dirname + \"/lib/scripts/drop_schema.sql\";\n  var sql = fs.readFileSync(docSqlFile, {encoding: 'utf-8'});\n  // Default to restrict, but optional cascade\n  var cascadeOpt = options && options.cascade === true ? \"CASCADE\" : \"\";\n  sql = util.format(sql, schemaName, cascadeOpt);\n  return sql;\n};\n\n\n\n//A recursive directory walker that would love to be refactored\nvar walkSqlFiles = function(rootObject, rootDir) {\n  var dirs;\n  try {\n    dirs = fs.readdirSync(rootDir);\n  } catch (ex) {\n     return;\n  }\n\n  //loop the directories found\n  _.each(dirs, function(item){\n    //parsing with path is a friendly way to get info about this dir or file\n    var ext = path.extname(item);\n    var name = path.basename(item, ext);\n\n    //is this a SQL file?\n    if (ext === \".sql\") {\n      //why yes it is! Build the abspath so we can read the file\n      var filePath = path.join(rootDir,item);\n\n      //pull in the SQL - don't worry this only happens once, when\n      //massive is loaded using connect()\n      //remove the unicode Byte Order Mark\n      var sql = stripBom(fs.readFileSync(filePath, {encoding : \"utf-8\"}));\n\n      var _exec = new Executable({\n        sql: sql,\n        filePath: filePath,\n        name : name,\n        db : self\n      });\n\n      // unfortunately we can't use MapToNamespace here without making a ton of changes\n      // since we need to accommodate deeply-nested directories rather than 1-deep schemata\n      self.queryFiles.push(_exec);\n      rootObject[name] = function () {\n        return _exec.invoke.apply(_exec, arguments);\n      };\n    } else if (ext === '') {\n      //this is a directory so shift things and move on down\n      //set a property on our root object, then use *that*\n      //as the root in the next call\n      rootObject[name] = {};\n\n      //set the path to walk so we have a correct root directory\n      var pathToWalk = path.join(rootDir,item);\n\n      //recursive call - do it all again\n      walkSqlFiles(rootObject[name], pathToWalk);\n    }\n  });\n};\n\nMassive.prototype.loadFunctions = function(next) {\n  if (!this.excludeFunctions) {\n    var functionSql = __dirname + \"/lib/scripts/functions.sql\";\n    var parameters = [this.functionBlacklist, this.functionWhitelist];\n\n    this.executeSqlFile({file : functionSql, params : parameters}, function (err,functions) {\n      if (err) {\n        next(err, null);\n      } else {\n        _.each(functions, function(fn) {\n          var schema = fn.schema;\n          var sql;\n          var params = [];\n\n          for (var i = 1; i <= fn.param_count; i++) {\n            params.push(\"$\" + i);\n          }\n\n          if (schema !== \"public\") {\n            sql = util.format(\"select * from \\\"%s\\\".\\\"%s\\\"\", schema, fn.name);\n            self[schema] = self[schema] || {};\n          } else {\n            sql = util.format(\"select * from \\\"%s\\\"\", fn.name);\n          }\n\n          sql += \"(\" + params.join(\",\") + \")\";\n\n          var _exec = new Executable({\n            sql: sql,\n            schema: schema,\n            name : fn.name,\n            db : self,\n            singleRow: self.enhancedFunctions && fn.return_single_row,\n            singleValue: self.enhancedFunctions && fn.return_single_value\n          });\n\n          MapToNamespace(_exec, \"functions\");\n        });\n\n        next(null, self);\n      }\n    });\n  } else {\n    next(null, self);\n  }\n};\n\n//connects Massive to the DB\nexports.connect = function(args, next) {\n  //override if there's a db name passed in\n  if (args.db) {\n    args.connectionString = \"postgres://localhost/\"+args.db;\n  } else if (!args.connectionString) {\n    return next(new Error(\"Need a connectionString or db (name of database on localhost) to connect.\"));\n  }\n\n  var massive = new Massive(args);\n\n  //load up the tables, queries, and commands\n  massive.loadTables(function(err, db) {\n    if (err) { return next(err); }\n\n    self = db;\n\n    massive.loadDescendantTables(function () {\n      if (err) { return next(err); }\n\n      massive.loadViews(function() {\n        if (err) { return next(err); }\n\n        massive.loadFunctions(function(err, db) {\n          if (err) { return next(err); }\n\n          db.loadQueries(); // synchronous\n\n          next(null, db);\n        });\n      });\n    });\n  });\n};\n\nexports.loadSync = DA(this.connect);\nexports.connectSync = DA(this.connect);\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/runner.js":"var pg = require(\"pg\");\nvar fs = require(\"fs\");\nvar _ = require(\"underscore\")._;\nvar ArgTypes = require(\"./arg_types\");\nvar QueryStream = require('pg-query-stream');\n\n//Prototype for the DB namespace\nvar DB = function(connectionString, defaults) {\n  this.connectionString = connectionString;\n  this.defaults = defaults;\n\n  if (defaults) {\n    _.each(defaults, function (v, k) {\n      pg.defaults[k] = v;\n    });\n  }\n};\n\nDB.prototype.query = function () {\n  //we expect sql, options, params and a callback\n  var args = ArgTypes.queryArgs(arguments);\n  var e = new Error();  // initialize error object before we do any async stuff to get a useful stacktrace\n\n  //check to see if the params are an array, which they need to be\n  //for the pg module\n  if(_.isObject(args.params)){\n    //we only need the values from the object,\n    //so swap it out\n    args.params = _.values(args.params);\n  }\n\n  //weird param bug that will mess up multiple statements\n  //with the pg_node driver\n  if(args.params === [{}]) args.params = [];\n\n  pg.connect(this.connectionString, function (err, db, done) {\n    if (err) {\n      done();\n\n      return args.next(err,null);\n    }\n\n    db.query(args.sql, args.params, function (err, result) {\n      //we have the results, release the connection\n      done();\n\n      if (err) {\n        //DO NOT THROW if there's a query error\n        //bubble it up\n        //handle if it's that annoying parameter issue\n        //wish I could find a way to deal with this\n        if (err.toString().indexOf(\"there is no parameter\") > -1) {\n          e.message = \"You need to wrap your parameter into an array\";\n        } else {\n          e.message = err.message || err.toString();\n          e.code = err.code;\n          e.detail = err.detail;\n        }\n\n        args.next(_.defaults(e, err), null);\n      } else {\n        //only return one result if single is sent in\n        if (args.options.single) {\n          result.rows = result.rows.length >= 0 ? result.rows[0] : null;\n        }\n\n        args.next(null, result.rows);\n      }\n    });\n  });\n};\n\nDB.prototype.stream = function () {\n  //we expect sql, options, params and a callback\n  var args = ArgTypes.queryArgs(arguments);\n\n  //check to see if the params are an array, which they need to be\n  //for the pg module\n  if(_.isObject(args.params)){\n    //we only need the values from the object,\n    //so swap it out\n    args.params = _.values(args.params);\n  }\n\n  //weird param bug that will mess up multiple statements\n  //with the pg_node driver\n  if(args.params === [{}]) args.params = [];\n\n  pg.connect(this.connectionString, function (err, db, done) {\n    if (err) {\n      done();\n\n      return args.next(err,null);\n    }\n\n    var query = new QueryStream(args.sql, args.params);\n\n    var stream = db.query(query);\n\n    stream.on('end', done);\n\n    args.next(null, stream);\n  });\n};\n\n//convenience function\nDB.prototype.executeSqlFile = function(args,next){\n  var self = this;\n  var fileSql = fs.readFileSync(args.file, {encoding: 'utf-8'});\n  self.query({sql:fileSql, params: args.params, next: next});\n};\n\n// close connections immediately\nDB.prototype.end = function(){\n  pg.end();\n};\n\nmodule.exports = DB;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/arg_types.js":"/* eslint-disable no-console */\n\nvar Args = require(\"args-js\");\nvar _ = require(\"underscore\")._;\nvar Query = require('./query');\n\n//TODO: Duplication in here, DRY it up...\n\n//A Wrapper for arguments used with Table.query\nexports.queryArgs = function(args){\n  args = Args([\n    {sql : Args.STRING | Args.Required},\n    {params : Args.ARRAY | Args.Optional, _default : []},\n    {options : Args.OBJECT | Args.Optional, _default : {single : false}},\n    {next : Args.FUNCTION | Args.Optional, _default : function(err,res){\n      if(err) console.log(err);\n      else console.log(res);\n    }}\n  ], args);\n  if(!_.isArray(args.params)) args.params = [args.params];\n  return args;\n};\n\n//Used with Table.where and Table.count\nexports.whereArgs = function(args, source){\n  args = Args([\n    {where : Args.STRING | Args.Optional, _default : \"true\"},\n    {params : Args.ANY | Args.Optional, _default : []},\n    {next : Args.FUNCTION | Args.Optional, _default : function(err,res){\n      if(err) console.log(err);\n      else console.log(res);\n    }}\n  ], args);\n\n  if(!_.isArray(args.params)) args.params = [args.params];\n\n  args.query = new Query({}, source);\n  return args;\n};\n\n//Used with Table.search\nexports.searchArgs = function(args, source) {\n  args = Args([\n    {fields : Args.OBJECT | Args.Optional, _default: {}},\n    {options: Args.OBJECT | Args.Optional, _default: {}},\n    {next : Args.FUNCTION | Args.Optional, _default: function(err, res){\n      if(err) console.log(err);\n      else console.log(res);\n    }}\n  ], args);\n\n  args.query = new Query(args.options, source);\n\n  return args;\n};\n\n//Used with Table.find\nexports.findArgs = function(args, source) {\n  args = Args([\n    {conditions : Args.ANY | Args.Optional, _default : {}},\n    {options : Args.OBJECT | Args.Optional, _default: {}},\n    {next : Args.FUNCTION | Args.Optional, _default : function(err,res){\n      if(err) console.log(err);\n      else console.log(res);\n    }}\n  ], args);\n\n  if (_.isFunction(args.conditions)) {\n    //this is our callback as the only argument, caught by Args.ANY\n    args.next = args.conditions;\n    args.conditions = {};\n  }\n\n  args.query = new Query(args.options, source);\n\n  return args;\n};\n\nexports.forArgs = function(args) {\n  return Args([\n    {conditions: Args.OBJECT},\n    {generator: Args.STRING | Args.Optional, _default: 'predicate'},\n    {placeholderOffset: Args.INT | Args.Optional, _default: 0},\n    {prefix: Args.STRING | Args.Optional, _default: ' \\nWHERE '}\n  ], args);\n};\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/query.js":"var _ = require(\"underscore\")._;\nvar util = require(\"util\");\n\nvar Query = function(args, object) {\n  this.source = object.delimitedFullName;\n  this.columns = args.columns || \"*\";\n  this.only = args.only || false;\n  this.order = args.order || (object.hasOwnProperty(\"pk\") ? util.format('\"%s\"', object.pk) : \"1\");\n  this.orderBody = args.orderBody || false;\n  this.offset = args.offset;\n  this.limit = args.limit;\n  this.stream = args.stream;\n  this.single = args.single || false;\n};\n\nQuery.prototype.format = function (where) {\n  var from = this.only ? \" FROM ONLY \" : \" FROM \";\n\n  return \"SELECT \" + this.selectList() + from + this.source + where + this.queryOptions();\n};\n\nQuery.prototype.selectList = function () {\n  if (_.isArray(this.columns)) {\n    return this.columns.join(',');\n  }\n\n  return this.columns;\n};\n\nQuery.prototype.queryOptions = function () {\n  if (_.isArray(this.order)) {\n    var orderBody = this.orderBody;\n\n    this.order = _.reduce(this.order, function (acc, val) {\n      val.direction = val.direction || \"asc\";\n\n      if (orderBody) {\n        val.field = util.format(\"body->>'%s'\", val.field);\n      }\n\n      if (val.type) {\n        acc.push(util.format(\"(%s)::%s %s\", val.field, val.type, val.direction));\n      } else {\n        acc.push(util.format(\"%s %s\", val.field, val.direction));\n      }\n\n      return acc;\n    }, []).join(\",\");\n  }\n\n  var sql = \"\";\n\n  if (this.order) { sql = \" order by \" + this.order; }\n  if (this.offset) { sql += \" offset \" + this.offset; }\n  if (this.limit || this.single) { sql += \" limit \" + (this.limit || \"1\"); }\n\n  return sql;\n};\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/executable.js":"var _ = require(\"underscore\")._;\nvar util = require('util');\nvar Entity = require('./entity');\nvar Transform = require('stream').Transform;\nvar inherits = require('util').inherits;\n\n// Takes a single-key object like {\"foo\": 27} and just returns the 27 part\nfunction _processSingleValue(data) {\n  if (!_.isNull(data)) {\n    var keys = Object.keys(data);\n    if (keys.length != 1) {\n      throw new Error(\"Was expecting just one value\");\n    }\n    data = data[keys[0]];\n  }\n  return data;\n}\n\nfunction SingleValueStream(options) {\n  if (!(this instanceof SingleValueStream)) {\n    return new SingleValueStream(options);\n  }\n  if (!options) {\n    options = {};\n  }\n  options.objectMode = true;\n  Transform.call(this, options);\n}\n\ninherits(SingleValueStream, Transform);\n\nSingleValueStream.prototype._transform = function _transform(obj, encoding, callback) {\n  try {\n    obj = _processSingleValue(obj);\n  } catch(err) {\n    return callback(err);\n  }\n  this.push(obj);\n  callback();\n};\n\n/**\n * An executable function or script.\n */\nvar Executable = function(args) {\n  Entity.apply(this, arguments);\n\n  this.sql = args.sql;\n  this.filePath = args.filePath;\n  this.singleRow = args.singleRow;\n  this.singleValue = args.singleValue;\n};\n\nutil.inherits(Executable, Entity);\n\n\n// invoke with:\n//   db.function(opts, callback)\n//   db.function([arg1, arg2, ...], opts, callback)\n//   db.function(arg1, arg2, ..., opts, callback)\n//\n//  where opts is optional and can be left out\n//        args must be scalar types (no arrays or objects)\n\nExecutable.prototype.invoke = function() {\n\n  var args = Array.prototype.slice.call(arguments);\n  var next = args.pop();\n  var opts = {};\n  var params = [];\n\n  if (!_.isFunction(next)) {\n    throw \"Function or Script Execution expects a next function as the last argument\";\n  }\n\n  if (!_.isArray(_.last(args)) && _.isObject(_.last(args))) {\n    opts = args.pop();\n  }\n\n  if (_.isArray(args[0])) {          // backwards compatible -- db.function([...], ?opts, callback)\n    params = args[0];\n  } else {\n    params = args;\n  }\n\n  // console.log(\"invoke next: \", next);\n  // console.log(\"invoke opts: \", opts);\n  // console.log(\"invoke params: \", params);\n\n  var singleRow = this.singleRow && !opts.stream;\n  var singleValue = this.singleValue;\n\n  if (opts.stream) {\n    this.db.stream(this.sql, params, null, function (err, stream) {\n      if (err) return next(err);\n      if (singleValue) {\n        var singleValueTransform = SingleValueStream();\n        return next(null, stream.pipe(singleValueTransform));\n      } else {\n        return next(null, stream);\n      }\n    });\n  } else {\n    this.db.query(this.sql, params, null, function (err, rawData) {\n      var data = rawData;\n      if (err) return next(err);\n      try {\n        if (singleRow) {\n          if (!Array.isArray(data)) {\n            return next(new Error(\"Was expecting an array\"));\n          }\n          data = data[0] || null;\n          if (singleValue) {\n            data = _processSingleValue(data);\n          }\n        } else {\n          if (singleValue) {\n            data = data.map(_processSingleValue);\n          }\n        }\n      } catch (e) {\n        err = e;\n      }\n      return next(err, data);\n    });\n  }\n};\n\nmodule.exports = Executable;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/entity.js":"/**\n * Base class for any database entity.\n * @param {[type]} args [description]\n */\nvar Entity = function(args) {\n  this.schema = args.schema || 'public';\n  this.name = args.name;\n  this.db = args.db;\n\n  // create delimited names now instead of at query time\n  this.delimitedName = \"\\\"\" + this.name + \"\\\"\";\n  this.delimitedSchema = \"\\\"\" + this.schema + \"\\\"\";\n\n  // handle naming when schema is other than public:\n  if(this.schema !== \"public\") {\n    this.fullname = this.schema + \".\" + this.name;\n    this.delimitedFullName = this.delimitedSchema + \".\" + this.delimitedName;\n  } else {\n    this.fullname = this.name;\n    this.delimitedFullName = this.delimitedName;\n  }\n};\n\nmodule.exports = Entity;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/queryable.js":"var _ = require(\"underscore\")._;\nvar assert = require(\"assert\");\nvar util = require('util');\nvar Entity = require('./entity');\nvar Where = require(\"./where\");\nvar ArgTypes = require(\"./arg_types\");\nvar DA = require(\"deasync\");\n\n/**\n * Represents a queryable database entity (table or view).\n * @param {[type]} args [description]\n */\nvar Queryable = function() {\n  Entity.apply(this, arguments);\n\n  // create delimited names now instead of at query time\n  this.delimitedName = \"\\\"\" + this.name + \"\\\"\";\n  this.delimitedSchema = \"\\\"\" + this.schema + \"\\\"\";\n\n  // handle naming when schema is other than public:\n  if(this.schema !== \"public\") {\n    this.fullname = this.schema + \".\" + this.name;\n    this.delimitedFullName = this.delimitedSchema + \".\" + this.delimitedName;\n  } else {\n    this.fullname = this.name;\n    this.delimitedFullName = this.delimitedName;\n  }\n};\n\nutil.inherits(Queryable, Entity);\n\n//a simple alias for returning a single record\nQueryable.prototype.findOne = function() {\n  var args = ArgTypes.findArgs(arguments, this);\n\n  this.find(args.conditions, args.query, function(err,results) {\n    if (err) {\n      args.next(err,null);\n    } else {\n      var result;\n\n      if (_.isArray(results)) {\n        if (results.length > 0) { result = results[0]; }\n      } else {\n        result = results;\n      }\n\n      args.next(null,result);\n    }\n  });\n};\nQueryable.prototype.findOneSync = DA(Queryable.prototype.findOne);\n\n/**\n * Counts rows and calls back with any error and the total. There are two ways to use this method:\n *\n * 1. find() style: db.mytable.count({field: value}, callback);\n * 2. where() style: db.mytable.count(\"field=$1\", [value], callback);\n */\nQueryable.prototype.count = function() {\n  var args;\n  var where;\n\n  if (_.isObject(arguments[0])) {\n    args = ArgTypes.findArgs(arguments, this);\n    where = _.isEmpty(args.conditions) ? {where : \" \"} : Where.forTable(args.conditions);\n  } else {\n    args = ArgTypes.whereArgs(arguments, this);\n    where = {where: \" where \" + args.where};\n  }\n\n  args.query.columns = \"COUNT(1)\";\n  args.query.order = null;\n  var sql = args.query.format(where.where);\n\n  this.db.query(sql, where.params || args.params, {single : true}, function(err, res) {\n    if (err) args.next(err, null);\n    else args.next(null, res.count);\n  });\n};\nQueryable.prototype.countSync = DA(Queryable.prototype.count);\n\n//a simple way to just run something\n//just pass in \"id=$1\" and the criteria\nQueryable.prototype.where = function(){\n  var args = ArgTypes.whereArgs(arguments, this);\n\n  var sql = args.query.format(\"where \" + args.where);\n\n  this.db.query(sql, args.params, args.next);\n};\nQueryable.prototype.whereSync = DA(Queryable.prototype.where);\n\nQueryable.prototype.find = function() {\n  var args = ArgTypes.findArgs(arguments, this);\n\n  if (typeof this.primaryKeyName === 'function' && Where.isPkSearch(args.conditions)) {\n    var newArgs = {};\n    newArgs[this.primaryKeyName()] = args.conditions;\n    args.conditions = newArgs;\n    args.query.single = true;\n  }\n\n  var where = _.isEmpty(args.conditions) ? {where: \" \"} : Where.forTable(args.conditions);\n  var sql = args.query.format(where.where);\n\n  if (args.query.stream) {\n    this.db.stream(sql, where.params, args.query, args.next);\n  } else {\n    this.db.query(sql, where.params, args.query, args.next);\n  }\n};\nQueryable.prototype.findSync = DA(Queryable.prototype.find);\n\nQueryable.prototype.search = function(args, next){\n  //search expects a columns array and the term\n  assert(args.columns && args.term, \"Need columns as an array and a term string\");\n\n  if(!_.isArray(args.columns)){\n    args.columns = [args.columns];\n  }\n\n  var tsv;\n  var vectorFormat = 'to_tsvector(\"%s\")';\n  if(args.columns.length === 1){\n    tsv = util.format(\"%s\", args.columns[0]);\n  }else{\n    vectorFormat = 'to_tsvector(%s)';\n    tsv= util.format(\"concat('%s')\", args.columns.join(\", ', '\"));\n  }\n  var sql = \"select * from \" + this.delimitedFullName + \" where \" + util.format(vectorFormat, tsv);\n  sql+= \" @@ to_tsquery($1);\";\n\n  this.db.query(sql, [args.term],next);\n};\nQueryable.prototype.searchSync = DA(Queryable.prototype.search);\n\nmodule.exports = Queryable;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/where.js":"var ArgTypes = require(\"./arg_types\");\nvar operationsMap = require(\"./operations_map\");\nvar _ = require(\"underscore\")._;\nvar util = require(\"util\");\nvar isUuid = new RegExp(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);\n\nfunction strip(arr) {\n  return _.without(arr.map(function (s) { return s.trim(); }), '');\n}\n\nfunction getOp(str) {\n  str = str.toLowerCase();\n\n  return _.reduce(operationsMap, function (acc, v, k) {\n    var idx = str.indexOf(k);\n\n    // if we matched something (eg '!' for 'not equal') previously and now have\n    // matched a longer operator (eg '!~~' for 'not like'), the more specific\n    // operator is the correct one.\n    if (idx > -1 && v.operator.length > acc.key.length) {\n      // '>' is a special case because it can also appear as part of a JSON\n      // traversal operator, so we need to be sure that's not what we're seeing\n      if (k !== '>' || (str.indexOf('->>', idx - 1) === -1 && str.indexOf('#>>', idx - 1) === -1)) {\n        v.key = k;  // save the original key so we can split on it even if user passed in alternate form\n\n        return v;\n      }\n    }\n\n    return acc;\n  }, {key: ''});\n}\n\n/**\n * Parse out a criterion key into something more intelligible. Supports quoted\n * field names and whitespace between components.\n * @param  {String} key Key in a format resembling \"field [JSON operation+path] operation\"\n * @return {Object}     [description]\n */\nexports.parseKey = function (key) {\n  // remove single quotes from JSON keys, then split on double quotes to break\n  // out \"quoted field\"s safely\n  var parts = strip(key.replace(/\\'/g, '').split('\"')),\n    operation = getOp(key),\n    separators = ['::', '\\\\-\\\\>\\\\>','\\\\#\\\\>\\\\>'],\n    re;\n\n  if (operation.key) {\n    // we found an operation, include the escaped key in the separators when we tokenize\n    separators.push(operation.key.replace(/([^a-zA-Z0-9\\s])/g, '\\\\$1'));\n  }\n\n  // capture separators in output array\n  re = new RegExp(util.format(\"(%s)\", separators.join('|')), 'i');\n\n  if (parts.length === 0) {\n    // the field wasn't quoted, so parts[0] is the whole thing\n    parts = strip(parts[0].split(re));\n  } else {\n    // the field was quoted, so parts[0] is the full field name, but parts[1]\n    // may contain JSON traversal and/or operations so split it up on those\n    parts = parts.concat(strip(parts.pop().split(re)));\n  }\n\n  var field = parts.shift(),\n    quotedField;\n\n  if (parts[0] === '::') {\n    // casting\n    var type = parts.shift() && parts.shift();\n\n    quotedField = util.format('\"%s\"::%s', field, type);\n    field = util.format('%s::%s', field, type);\n  } else {\n    quotedField = util.format('\"%s\"', field);\n  }\n\n  if (parts[0] === '->>' || parts[0] === '#>>') {\n    // json operation. pull the op and key out and append them to the field.\n    var jsonOp = parts.shift();\n    var jsonKey = parts.shift();\n\n    // treat numeric json keys as array indices, otherwise quote it\n    if (isNaN(jsonKey)) { jsonKey = util.format(\"'%s'\", jsonKey); }\n\n    quotedField = util.format('%s%s%s', quotedField, jsonOp, jsonKey);\n  }\n\n  return {\n    field: field,\n    quotedField: quotedField,\n    operator: operation.operator || '=',\n    mutator: operation.mutator\n  };\n};\n\nexports.predicate = function (result, condition, value) {\n  if (value === null) {\n    //interpolate nulls directly with is/is not\n    condition.operator = condition.operator === '=' ? 'IS' : 'IS NOT';\n  } else if (condition.mutator || !_.isArray(value)) {\n    //parameterize any non-array or mutatey values\n    if (condition.mutator) { value = condition.mutator(value); }\n    result.params.push(value);\n    value = util.format(\"$%s\", result.params.length + result.offset);\n  } else if (_.isArray(value)) {\n    var arrayConditions = [];\n\n    //loop the array\n    _.each(value, function(v) {\n      result.params.push(v);\n      arrayConditions.push(util.format(\"$%s\", result.params.length + result.offset));\n    });\n\n    condition.operator = condition.operator === '=' ? 'IN' : 'NOT IN';\n\n    value = util.format('(%s)', arrayConditions.join(', '));\n  }\n\n  result.predicates.push(util.format('%s %s %s', condition.quotedField, condition.operator, value));\n\n  return result;\n};\n\nexports.docPredicate = function (result, condition, value, conditions) {\n  //if we have an array of objects, this is a deep traversal\n  //we'll need to use a contains query to be sure we flex the index\n  if(_.isArray(value) && _.isObject(value[0])) {\n    //stringify the passed-in params\n    result.params.push(JSON.stringify(conditions));\n    result.predicates.push(util.format(\"body @> $%s\", result.params.length + result.offset));\n  }\n\n  //if we have equality here, just use a JSON contains\n  else if (condition.operator === '=' && !_.isArray(value)) {\n    //parse the value into stringy JSON\n    var param = {};\n    param[condition.field]=value;\n    result.params.push(JSON.stringify(param));\n    result.predicates.push(util.format(\"body @> $%s\", result.params.length + result.offset));\n    return result;\n  }\n\n  //comparison stuff - same as method above but this time\n  //we'll be coercing the document key values using pg's ::\n  //not ideal, but it works nicely\n  else if (_.isBoolean(value)) {\n    result.predicates.push(\n      util.format(\"(body ->> '%s')::boolean %s %s\", condition.field, condition.operator, value)\n    );\n  } else if(_.isDate(value)) {\n    result.params.push(value);\n    result.predicates.push(\n      util.format(\"(body ->> '%s')::timestamp %s $%d\",\n        condition.field,\n        condition.operator,\n        result.params.length + result.offset)\n    );\n  } else if(_.isNumber(value)) {\n    result.predicates.push(\n      util.format(\"(body ->> '%s')::decimal %s %d\", condition.field, condition.operator, value)\n    );\n  }\n\n  //anything non-array handling\n  else if (!_.isArray(value)) {\n    result.params.push(value);\n    result.predicates.push(\n      util.format(\"(body ->> '%s') %s $%s\",\n        condition.field,\n        condition.operator,\n        result.params.length + result.offset)\n    );\n  } else {\n    var arrayConditions = [];\n\n    _.each(value, function(v) {\n      result.params.push(v);\n      arrayConditions.push(\"$\" + (result.params.length + result.offset));\n    });\n\n    condition.operator = condition.operator === '=' ? 'IN' : 'NOT IN';\n\n    result.predicates.push(\n      util.format(\"(body ->> '%s') %s (%s)\",\n        condition.field,\n        condition.operator,\n        arrayConditions.join(', '))\n    );\n  }\n\n  return result;\n};\n\nexports.generate = function (result, conditions, generator) {\n  _.each(conditions, function(value, key) {\n    var condition = exports.parseKey(key);\n\n    if (condition.field === 'or') {\n      if (!_.isArray(value)) { value = [value]; }\n\n      var groupResult = _.reduce(value, function (acc, v) {\n        // assemble predicates for each subgroup in this 'or' array\n        var subResult = exports.generate({\n          params: [],\n          predicates: [],\n          offset: result.params.length + acc.offset   // ensure the offset from predicates outside the subgroup is counted\n        }, v, generator);\n\n        // encapsulate and join the individual predicates with AND to create the complete subgroup predicate\n        acc.predicates.push(util.format('(%s)', subResult.predicates.join(' AND ')));\n        acc.params = acc.params.concat(subResult.params);\n        acc.offset += subResult.params.length;\n\n        return acc;\n      }, {\n        params: [],\n        predicates: [],\n        offset: result.offset\n      });\n\n      // join the compiled subgroup predicates with OR, encapsulate, and push the\n      // complex predicate (\"((x = $1 AND y = $2) OR (z = $3))\") onto the result object\n      result.params = result.params.concat(groupResult.params);\n      result.predicates.push(util.format('(%s)', groupResult.predicates.join(' OR ')));\n    } else {\n      // no special behavior, just add this predicate and modify result in-place\n      result = exports[generator](result, condition, value, conditions);\n    }\n  });\n\n  return result;\n};\n\nexports.forTable = function () {\n  var args = ArgTypes.forArgs(arguments);\n\n  if (_.isEmpty(args.conditions)) {\n    return {\n      where: args.prefix + 'TRUE',\n      params: []\n    };\n  }\n\n  var result = exports.generate({\n    params: [],\n    predicates: [],\n    offset: args.placeholderOffset\n  }, args.conditions, args.generator);\n\n  return {\n    where: args.prefix + result.predicates.join(' \\nAND '),\n    params: result.params\n  };\n};\n\nexports.isPkSearch = function(conditions) {\n  return _.isNumber(conditions) || (_.isString(conditions) && isUuid.test(conditions));\n};\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/operations_map.js":"var _ = require('underscore')._;\nvar util = require(\"util\");\n\nfunction literalizeArray(arr) {\n  if (!_.isArray(arr)) { return arr; }\n\n  return util.format('{%s}', arr.map(function (v) {\n    if (v.search(/[,{}]/) !== -1) { return util.format('\"%s\"', v); }\n\n    return v;\n  }).join(','));\n}\n\nexports = module.exports = {\n  // basic comparison\n  '=': {operator: '='},\n  '!': {operator: '<>'},\n  '>': {operator: '>'},\n  '<': {operator: '<'},\n  '>=': {operator: '>='},\n  '<=': {operator: '<='},\n  '!=': {operator: '<>'},\n  '<>': {operator: '<>'},\n  // array\n  '@>': {operator: '@>', mutator: literalizeArray},\n  '<@': {operator: '<@', mutator: literalizeArray},\n  '&&': {operator: '&&', mutator: literalizeArray},\n  '?|': {operator: '?|', mutator: literalizeArray},\n  '?&': {operator: '?&', mutator: literalizeArray},\n  // pattern matching\n  '~~': {operator: 'LIKE'},\n  'like': {operator: 'LIKE'},\n  '!~~': {operator: 'NOT LIKE'},\n  'not like': {operator: 'NOT LIKE'},\n  '~~*': {operator: 'ILIKE'},\n  'ilike': {operator: 'ILIKE'},\n  '!~~*': {operator: 'NOT ILIKE'},\n  'not ilike': {operator: 'NOT ILIKE'},\n  'similar to': {operator: 'SIMILAR TO'},\n  'not similar to': {operator: 'NOT SIMILAR TO'},\n  // regex\n  '~': {operator: '~'},\n  '!~': {operator: '!~'},\n  '~*': {operator: '~*'},\n  '!~*': {operator: '!~*'},\n  // distinct\n  'is distinct from': {operator: 'IS DISTINCT FROM'},\n  'is not distinct from': {operator: 'IS NOT DISTINCT FROM'}\n};\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/table.js":"var _ = require(\"underscore\")._;\nvar assert = require(\"assert\");\nvar util = require('util');\nvar DocumentTable = require(\"./document_table\");\nvar Queryable = require(\"./queryable\");\nvar Where = require(\"./where\");\nvar DA = require(\"deasync\");\nvar ArgTypes = require(\"./arg_types\");\n\n//a simple wrapper for a table\nvar Table = function(args) {\n  Queryable.apply(this, arguments);\n\n  this.pk = args.pk;\n\n  _.extend(this,DocumentTable);\n};\n\nutil.inherits(Table, Queryable);\n\nTable.prototype.insert = function(data, next) {\n  var returnSingle = false;\n\n  if (!data) {\n    return next(new Error(\"insert should be called with data\"));\n  } else if (!_.isArray(data)) {\n    returnSingle = true;\n    data = [data];\n  } else if (data.length === 0) {\n    return next(null, []);  // just return empty arrays so bulk inserting variable-length lists is more friendly\n  }\n\n  var delimitedColumnNames = _.map(_.keys(data[0]), function(key){return util.format('\"%s\"', key);});\n  var sql = util.format(\"INSERT INTO %s (%s) VALUES\\n\", this.delimitedFullName, delimitedColumnNames.join(\", \"));\n  var parameters = [];\n  var values = [];\n  var fn = function() { return \"$\" + (++seed); };\n\n  for(var i = 0, seed = 0; i < data.length; ++i) {\n    var v = _.map(data[i], fn);\n    values.push(util.format('(%s)', v.join(', ')));\n    parameters.push(_.values(data[i]));\n  }\n  sql += values.join(\",\\n\");\n  sql += \" RETURNING *\";\n  this.db.query(sql, _.flatten(parameters, true), {single : returnSingle}, next);\n};\nTable.prototype.insertSync = DA(Table.prototype.insert);\n\nTable.prototype.update = function(conditions, fields, next) {\n  var hasConditions = true;\n  var options = {};\n\n  if (_.isFunction(fields)) {\n    var pkName = this.primaryKeyName();\n\n    hasConditions = false;\n    next = fields;\n    fields = conditions;\n    conditions = {};\n\n    conditions[pkName] = fields[pkName];\n\n    fields = _.omit(fields, function(value, key, object) {\n      return _.isFunction(object[key]) || key === pkName;\n    });\n\n    options.single = true;\n  }\n\n  assert(_.isObject(fields), \"Update requires a hash of fields=>values to update to\");\n\n  if (_.isEmpty(fields)) {\n    // there's nothing to update, so just return the matching records\n    if (options.single) {\n      return this.findOne(conditions, next);\n    } else {\n      return this.find(conditions, next);\n    }\n  }\n\n  var parameters = [];\n  var f = [];\n  var seed = 0;\n\n  _.each(fields, function(value, key) {\n    f.push(util.format('\"%s\" = $%s', key, (++seed)));\n    parameters.push(value);\n  });\n\n  var sql = util.format(\"UPDATE ONLY %s SET %s\", this.delimitedFullName, f.join(', '));\n\n  if (!hasConditions || !_.isEmpty(conditions)) {\n    var parsedWhere = Where.forTable(conditions, parameters.length);\n\n    sql += parsedWhere.where;\n  }\n\n  sql += \" RETURNING *\";\n\n  parameters = parameters.concat(\n    _.chain(conditions)\n    .values()\n    .flatten()\n    .without(null)  // nulls are inlined in the WHERE\n    .value()\n  );\n\n  this.db.query(sql, parameters, options, next);\n};\nTable.prototype.updateSync = DA(Table.prototype.update);\n\nTable.prototype.primaryKeyName = function(){\n  return this.pk;\n};\n\nTable.prototype.delimitedPrimaryKeyName = function() {\n  return util.format('\"%s\"', this.pk);\n};\n\nTable.prototype.containsPk = function(args){\n  var keys = _.keys(args);\n  return (keys.indexOf(this.primaryKeyName()) > -1) || (keys.indexOf(this.delimitedPrimaryKeyName()) > -1);\n};\n\nTable.prototype.save = function(args, next){\n  assert(_.isObject(args), \"Please pass in the criteria for saving as an object. This should include all fields needed to change or add. Include the primary key for an UPDATE.\");\n\n  if(this.containsPk(args)){\n    this.update(args,next);\n  }else{\n    this.insert(args,next);\n  }\n};\nTable.prototype.saveSync = DA(Table.prototype.save);\n\nTable.prototype.destroy = function(args, next){\n  assert(_.isObject(args), \"Please pass in the criteria for deleting. This should be in object format - {id : 1} for example\");\n  var sql = \"DELETE FROM ONLY \" + this.delimitedFullName;\n  var where = {};\n\n  if (Object.keys(args).length > 0) {\n    where = Where.forTable(args);\n    sql += where.where;\n  }\n\n  sql += \" RETURNING *\";\n  this.db.query(sql, where.params, next);\n};\nTable.prototype.destroySync = DA(Table.prototype.destroy);\n\nTable.prototype.search = function(){\n  var args = ArgTypes.searchArgs(arguments, this);\n\n  //search expects a columns array and the term\n  assert(args.fields.columns && args.fields.term, \"Need columns as an array and a term string\");\n  var params = [args.fields.term];\n  if(!_.isArray(args.fields.columns)){\n    args.fields.columns = [args.fields.columns];\n  }\n  var tsv;\n  var vectorFormat = 'to_tsvector(\"%s\")';\n  if(args.fields.columns.length === 1){\n    tsv = util.format(\"%s\", args.fields.columns[0]);\n    if(args.fields.columns[0].indexOf('>>') !== -1){\n      vectorFormat = 'to_tsvector(%s)';\n    }\n  }else{\n    vectorFormat = 'to_tsvector(%s)';\n    tsv= util.format(\"concat(%s)\", args.fields.columns.join(\", ' ', \"));\n  }\n\n  var whereString = \"\";\n  if (args.fields.where) {\n    var where = Where.forTable(args.fields.where, 'predicate', 1, \" AND \");\n    whereString = where.where;\n    params = params.concat(where.params);\n  }\n  var sql = args.query.format(util.format(\" WHERE \" + vectorFormat + \" @@ to_tsquery($1) %s\", tsv, whereString));\n  this.db.query(sql, params, args.options, args.next);\n};\nTable.prototype.searchSync = DA(Table.prototype.search);\n\nmodule.exports = Table;\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/document_table.js":"var _ = require(\"underscore\")._;\nvar assert = require(\"assert\");\nvar util = require('util');\nvar Document = require(\"./document\");\nvar Where = require(\"./where\");\nvar ArgTypes = require(\"./arg_types\");\nvar DA = require(\"deasync\");\n\n//Searching query for jsonb docs\nexports.searchDoc = function(){\n  var args = ArgTypes.searchArgs(arguments, this);\n  assert(args.fields.keys && args.fields.term, \"Need the keys to use and the term string\");\n  var params = [args.fields.term];\n  //yuck full repetition here... fix me...\n  if(!_.isArray(args.fields.keys)){\n    args.fields.keys = [args.fields.keys];\n  }\n  var tsv;\n  if(args.fields.keys.length === 1){\n    tsv = util.format(\"(body ->> '%s')\", args.fields.keys[0]);\n  }else{\n    var formattedKeys = [];\n    _.each(args.fields.keys, function(key){\n      formattedKeys.push(util.format(\"(body ->> '%s')\", key));\n    });\n    tsv= util.format(\"concat(%s)\", formattedKeys.join(\", ' ',\"));\n  }\n\n  var whereString = \"\";\n\n  if (args.fields.where) {\n    var where = this.getWhereForDoc(args.fields.where, 1, \" AND \");\n    whereString = where.where;\n    params = params.concat(where.params);\n  }\n\n  var sql = args.query.format(util.format(\" WHERE to_tsvector(%s) @@ to_tsquery($1) %s\", tsv, whereString));\n\n  this.executeDocQuery(sql, params, args.options, args.next);\n};\nexports.searchDocSync = DA(this.searchDoc);\n\nexports.saveDoc = function(args, next) {\n  assert(_.isObject(args), \"Please pass in the document for saving as an object. Include the primary key for an UPDATE.\");\n  var sql, params = [];\n  var pkName = this.primaryKeyName();\n  var pkVal = args[pkName];\n\n  // if there's a primary key, don't store it in the body as well\n  params.push(JSON.stringify(_.omit(args, pkName)));\n\n  if (pkVal) {\n    sql = util.format(\"update %s set body = $1 where %s = $2 returning *;\", this.fullname, pkName);\n    params.push(pkVal);\n  } else {\n    sql = \"insert into \" + this.fullname + \"(body) values($1) returning *;\";\n  }\n\n  this.executeDocQuery(sql, params, {single : true}, next);\n};\nexports.saveDocSync = DA(this.saveDoc);\n\n// Only works for jsonb column type and Postgresql 9.5\nexports.setAttribute = function(id, key, val, next){\n  if (typeof val === 'string') { val = JSON.stringify(val); }\n  if (Array.isArray(val)) { val = JSON.stringify(val); }\n\n  var pkName = this.primaryKeyName();\n  var params = [\"{\"+key+\"}\", val, id];\n  var sql = util.format(\"update %s set body=jsonb_set(body, $1, $2, true) where %s = $3 returning *;\", this.fullname, pkName);\n  this.executeDocQuery(sql, params, {single:true}, next);\n};\nexports.setAttributeSync = DA(this.setAttribute);\n\nexports.findDoc = function() {\n  var args = ArgTypes.findArgs(arguments, this);\n\n  var where = this.getWhereForDoc(args.conditions);\n\n  if (where.pkQuery) { args.options.single = true; }\n\n  var sql = args.query.format(where.where);\n\n  this.executeDocQuery(sql, where.params, args.options, args.next);\n};\nexports.findDocSync = DA(this.findDoc);\n\nthis.getWhereForDoc = function(conditions, offset, prefix) {\n  var where = {pkQuery: false};\n  if(_.isFunction(conditions) || conditions == \"*\") {\n    // no criteria provided - treat like select *\n    where.where = \"\";\n    where.params = [];\n    return where;\n  }\n\n  if (Where.isPkSearch(conditions)) {\n    //assume it's a search on ID\n    conditions = {id : conditions};\n  }\n\n  if (_.isObject(conditions)) {\n    var keys = _.keys(conditions);\n\n    if (keys.length === 1) {\n      var operator = keys[0].match(\"<=|>=|!=|<>|=|<|>\");\n      var property = keys[0].replace(operator, \"\").trim();\n      if (property == this.primaryKeyName()) {\n        // this is a query against the PK...we can use the\n        // plain old table \"where\" builder:\n        where = Where.forTable(conditions, 'predicate', offset, prefix);\n\n        // only a true pk query if testing equality\n        if ((operator === null || operator === \"=\") && !_.isObject(conditions[keys[0]])) {\n          where.pkQuery = true;\n        }\n      } else {\n        where = Where.forTable(conditions, 'docPredicate', offset, prefix);\n      }\n    } else {\n      where = Where.forTable(conditions, 'docPredicate', offset, prefix);\n    }\n  }\n\n  return where;\n};\n\nthis.executeDocQuery = function() {\n  var args = ArgTypes.queryArgs(arguments);\n  var doc = {};\n  this.db.query(args.sql, args.params, args.options, function(err,res){\n    if(err){\n      args.next(err,null);\n    }else{\n      //only return one result if single is sent in\n      if(args.options.single){\n        doc = Document.formatDocument(res);\n      }else{\n        doc = Document.formatArray(res);\n      }\n      args.next(null,doc);\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/lib/document.js":"var _ = require(\"underscore\")._;\n\n//A simple helper function to manage document ids\nexports.formatArray = function(args){\n\n  var result = [];\n  _.each(args, function(doc){\n    result.push(this.formatDocument(doc));\n  }.bind(this));\n  return result;\n};\n\nexports.formatDocument = function(args){\n  var returnDoc = null;\n  if(args){\n    returnDoc = args.body || {};\n    returnDoc.id = args.id || null;\n  }\n  return returnDoc;\n};\n","/home/travis/build/npmtest/node-npmtest-massive/node_modules/massive/bin/massive.js":"#!/usr/bin/env node\n\n/* eslint-disable no-console */\n\nvar repl = require(\"repl\");\nvar massive = require(\"../index\");\nvar program = require('commander');\n\nprogram\n  .version('0.0.1')\n  .option('-d, --database', 'The local db you want to connect to ')\n  .option('-c, --connection', 'The full connection string')\n  .parse(process.argv);\n\nvar connectionString;\nif(program.database){\n  connectionString = \"postgres://localhost/\" + program.args[0]; //assume local user has rights\n}else if(program.connection) {\n  connectionString = program.args[0];\n}else{\n  console.log(\"The options to pass in are:\");\n  console.log(\" -d or --database to connect locally to a database\");\n  console.log(\" -c or --connection to enter the full connection string: postgres://user:password@server/tablename\");\n}\n\nif(connectionString){\n  massive.connect({connectionString : connectionString}, function(err,db){\n    var context = repl.start({\n      prompt: \"db > \"\n    }).context;\n    context.db = db;\n    console.log(\"Massive loaded and listening\");\n  });\n}\n"}